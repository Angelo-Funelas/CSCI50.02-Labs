*******************************************************************************
* Lab  #9
* - Francisco, Janelle Chloe
* - Funelas, Martin Angelo
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

*******************************************************************************
* Include alu32
.subckt fa a b c_in sum c_out
  Xsum1 a b sum1 xor2
  Xcarry1 a b carry1 nand2
  Xsum2 sum1 c_in sum xor2
  Xcarry2 sum1 c_in carry2 nand2
  Xcarry carry1 carry2 c_out nand2
.ends

.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xfa a[0:31] b[0:31] cin0 cout[0:30] sum[0:31] cout[0:31] fa
.ends

.subckt iszero32 a[31:0] z
  Xnor1 a[3:0] a[7:4] a[11:8] a[15:12] nor_out[3:0] nor4
  Xnor2 a[19:16] a[23:20] a[27:24] a[31:28] nor_out[7:4] nor4
  Xnand1 nor_out[1:0] nor_out[3:2] nor_out[5:4] nor_out[7:6] nand_out[1:0] nand4
  Xout nand_out0 nand_out1 z nor2
.ends

.subckt as32 a[31:0] b[31:0] op0 fas[31:0] n v z
  .connect fas31 n

  Xinv b[31:0] inv_b[31:0] inverter
  Xswitch op0#32 b[31:0] inv_b[31:0] x[31:0] mux2
  Xadd a[31:0] x[31:0] op0 fas[31:0] cout[31:30] add32
  Xeq cout31 cout30 v xor2
  Xcirc_z fas[31:0] z iszero32
.ends

.subckt cmp32 n v z op[2:1] fcmp[31:0]
  .connect 0 fcmp[31:1]

  Xinv2 n inv_n inverter
  Xswitch2 v n inv_n neg mux2
  Xor neg z lte or2
  Xcomp op2 op1 0 neg z lte fcmp0 mux4
.ends

.subckt bool32 a[31:0] b[31:0] op[3:0] fbool[31:0]
  Xbool a[0:31] b[0:31] op0#32 op1#32 op2#32 op3#32 fbool[0:31] mux4
.ends

.subckt shift32 a[31:0] b[4:0] op[1:0] fshift[31:0]
  Xarithm op1 0 a31 grnd mux2
  Xdir1 op0#32 a[0:31] a[31:0] num[31:0] mux2

  X16 b4#32 num[31:0] grnd#16 num[31:16] sixteen[31:0] mux2
  X8 b3#32 sixteen[31:0] grnd#8 sixteen[31:8] eight[31:0] mux2
  X4 b2#32 eight[31:0] grnd#4 eight[31:4] four[31:0] mux2
  X2 b1#32 four[31:0] grnd#2 four[31:2] two[31:0] mux2
  X1 b0#32 two[31:0] grnd two[31:1] one[31:0] mux2

  Xdir2 op0#32 one[0:31] one[31:0] fshift[31:0] mux2
.ends

.subckt alu32 a[31:0] b[31:0] alufn[5:0] f[31:0]
  Xaddsub a[31:0] b[31:0] alufn0 fas[31:0] n v z as32
  Xboolean a[31:0] b[31:0] alufn[3:0] fbool[31:0] bool32
  Xbshift a[31:0] b[4:0] alufn[1:0] fshift[31:0] shift32
  Xcompare n v z alufn[2:1] fcmp[31:0] cmp32

  Xalu alufn5#32 alufn4#32 fas[31:0] fshift[31:0] fbool[31:0] fcmp[31:0] f[31:0] mux4
.ends

* Include counter32
.subckt counter32 reset a[31:0] f[31:0] clk
  .connect clk regclk[31:0]
  .connect reset reset[31:0]
  .connect 0 gnd[31:0]

  Xinc a[31:0] f[31:0] 0 d[31:0] cout[31:30] add32
  Xreset reset[31:0] d[31:0] gnd[31:0] temp[31:0] mux2
  Xid temp[31:0] regclk[31:0] f[31:0] dreg
.ends
*******************************************************************************

Xmemory  vdd  0    0   pc[8:2]    inst[31:0]
+        vdd  0    0   mema[8:2]  memrd[31:0]
+        0    clk  wr  mema[8:2]  memwd[31:0]
+ $memory width=32 nlocations=128 file="lab7.bin"

Xregisters  vdd  0    0      ra1_[4:0]  rd1_[31:0]
+           vdd  0    0      ra2_[4:0]  rd2_[31:0]
+           0    clk  werf_  wa[4:0]    wd[31:0]
+ $memory width=32 nlocations=32 contents=(
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+   0 0 0 0 0 0 0 0
+ )

Xand1 wa2 wa1 wa0 and_out and3
Xand2 and_out wa4 wa3 rcheck and3
Xwerf rcheck werf 0 werf_ mux2

Xcontrol  vdd  0  0  z opcode[5:0]  control[13:0]
+ $memory width=14 nlocations=128 contents=(
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b00000000000001 0b01000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000 0b11000000000000
+   0b00011000000001 0b00110000000010 0b11000000000000 0b10000000000001 0b11000000000000 0b01000000000001 0b00000000000001 0b11000000000000
+   0b00000100000001 0b00000100000101 0b11000000000000 0b11000000000000 0b00000111001101 0b00000111010101 0b00000111011101 0b11000000000000
+   0b00000101100001 0b00000101111001 0b00000101011001 0b11000000000000 0b00000110000001 0b00000110000101 0b00000110001101 0b11000000000000
+   0b00010100000001 0b00010100000101 0b11000000000000 0b11000000000000 0b00010111001101 0b00010111010101 0b00010111011101 0b11000000000000
+   0b00010101100001 0b00010101111001 0b00010101011001 0b11000000000000 0b00010110000001 0b00010110000101 0b00010110001101 0b11000000000000
+ )

.subckt join S T
  .connect S T
.ends

Xjcontrola control[13:12] pcsel[1:0] join
Xjcontrolb control11      ra2sel     join
Xjcontrolc control10      bsel       join
Xjcontrold control[9:8]   wdsel[1:0] join
Xjcontrole control[7:2]   alufn[5:0] join
Xjcontrolf control1       wr         join
Xjcontrolg control0       werf       join

Xjinsta inst[31:26] opcode[5:0] join
Xjinstb inst[25:21] rc[4:0]     join
Xjinstc inst[20:16] ra[4:0]     join
Xjinstd inst[15:11] rb[4:0]     join
Xjinste inst[15:0]  c[15:0]     join


*******************************************************************************
* Temporarily connect pc[] to the predefined clocks so that we can view each
* instruction in sequence.
* Note that you will need to replace this with a real program counter circuit
* in the final lab!
*******************************************************************************
Xjpc clk[8:2] pc[8:2] join
.connect 0 pc[1:0]


*******************************************************************************
* Temporarily connect other undefined signals.
* Note that you will need to remove these signals from this section once you
* connect them elsewhere!
*******************************************************************************
.connect vdd clk ra1_[4:0] ra2_[4:0] wa[4:0] wd[31:0] mema[8:0] memwd[31:0]
.connect 0 z


*******************************************************************************
* Plot some signals together (or else we won't have enough space in the plot
* window)
*******************************************************************************
Xjdisplaya ra2_b_wdsel[3:0] ra2sel bsel wdsel[1:0] join
Xjdisplayb wr_werfs[2:0]    wr werf werf_          join

.tran 1280ns
.plot pc[8:0]
.plot betaop(opcode[5:0])
.plot d(ra[4:0])
.plot d(rb[4:0])
.plot d(rc[4:0])
.plot sd(c[15:0])
.plot b(pcsel[1:0])
.plot b(ra2_b_wdsel[3:0])
.plot b(alufn[5:0])
.plot b(wr_werfs[2:0])
.plot sd(rd1_[31:0])
.plot sd(rd2_[31:0])
.plot sd(wd[31:0])
.plot d(mema[8:0])
.plot sd(memrd[31:0])
.plot sd(memwd[31:0])