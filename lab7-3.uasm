|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| LAB #7-3
| - Francisco, Janelle Chloe
| - Funelas, Martin Angelo
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
| REGISTERS
| r0   the length of the KEY array
| r1   initially the length of the PLAINTEXT array; also used as a counter for when to stop the loop
| r2   address of the element of KEY currently being read
| r3   address of the element of PLAINTEXT currently being read
| r4   counter for KEY to determine whether or not to wrap around
| r5   determines if the counter (r4) is already pointing to the last element in the KEY array
| r6   amount of space to leave for the elements of the KEY array
| r7   amount of space to leave for the elements of the PLAINTEXT array
| r8   address of the element of ENCRYPTED currently being written into
| r9   result of the XOR between the KEY element and PLAINTEXT element
| r10  the element of KEY currently being used
| r11  the element of PLAINTEXT currently being used
| r12  determines whether or not the last element of PLAINTEXT has been used, thus determining whether to continue the loop or to stop the execution
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


.include beta.uasm
. = 0x00


        LD(r31, KEY, r0)                | load M into r0
        LD(r31, PLAINTEXT, r1)          | load N into r1
        ADDC(r31, 0x6c, r2)             | load address of first element of key into r2
        ADD(r31, r31, r4)               | create a counter for key
        MULC(r0, 4, r6)                 | multiply the length of the array with 4 to get the number of bits we need to leave for key
        ADDC(r6, 4, r6)                 | add 4 because there is an extra element indicating the length of the array
        ADD(r2, r6, r3)                 | load address of first element of plaintext into r3
        MULC(r1, 4, r7)                 | multiply the length of the array with 4 to get the number of bits we need to leave for plaintext
        ADDC(r7, 4, r7)                 | add 4 because there is an extra element indicating the length of the array
        ADD(r3, r7, r8)                 | load address of first element of encrypted into r8


keyloop: CMPEQ(r4, r0, r5)              | check if the PC is already pointing to the last element of key
        BEQ(r5, incr, r31)              | if not, proceed to incrementing the counter
        ADDC(r31, 0x6c, r2)             | if yes, reset PC to the first element of key
        ADD(r31, r31, r4)               | and reset the counter


incr:   ADDC(r4, 1, r4)                 | increment the counter
        ADDC(r2, 4, r2)                 | move PC to the address of the next element of key


plaintextloop: ADDC(r3, 4, r3)          | move PC to the address of the next element of plaintext
        LD(r3, 0, r10)                  | load the content in address r3 into r10
        LD(r2, 0, r11)                  | load the content in address r2 into r11
        XOR(r10, r11, r9)               | XOR an element of key and plaintext
        ST(r9, 0, r8)                   | store the result of the XOR into encrypted
        ADDC(r8, 4, r8)                 | update address of encrypted
        SUBC(r1, 1, r1)                 | decrement r1
        CMPEQ(r1, r31, r12)             | check if r1==0
        BEQ(r12, keyloop, r31)          | if not, return to keyloop
       
        HALT()                          | if yes, stop execution


. = 0x6c


KEY:    LONG(2)
        LONG(42)
        LONG(67)


PLAINTEXT: LONG(5)
        LONG(98)
        LONG(6)
        LONG(102)
        LONG(15)
        LONG(101)


ENCRYPTED:



