*******************************************************************************
* LAB #4
* - Francisco, Janelle Chloe
* - Funelas, Martin Angelo
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"

.subckt fa a b c_in sum c_out
  Xsum1 a b sum1 xor2
  Xcarry1 a b carry1 nand2
  Xsum2 sum1 c_in sum xor2
  Xcarry2 sum1 c_in carry2 nand2
  Xcarry carry1 carry2 c_out nand2
.ends

.subckt add32 a[31:0] b[31:0] cin0 sum[31:0] cout[31:30]
  Xfa a[0:31] b[0:31] cin0 cout[0:30] sum[0:31] cout[0:31] fa
.ends

.subckt counter32 reset a[31:0] f[31:0] clk
  .connect clk regclk[31:0]
  .connect reset reset[31:0]
  .connect 0 gnd[31:0]

  Xinc a[31:0] f[31:0] 0 d[31:0] cout[31:30] add32
  Xreset reset[31:0] d[31:0] gnd[31:0] temp[31:0] mux2
  Xid temp[31:0] regclk[31:0] f[31:0] dreg
.ends

Xcounter32 reset incr[31:0] reg[31:0] clk1 counter32

Wreset reset nrz(0, 5, 50ns, 15ns, 0.001ns, 0.001ns)
+ 1 0 0 0 1 0

Wincr incr[31:0] nrz(0, 5, 50ns, 0ns, 0.001ns, 0.001ns)
+ 0 1 3 -1

.tran 300ns
.plot reset
.plot sd(incr[31:0])
.plot clk1
.plot sd(reg[31:0])

*******************************************************************************
* The following was used to answer the guide questions:
*
* .subckt counter32_debug reset a[31:0] f[31:0] d[31:0] temp[31:0] clk
*   .connect clk regclk[31:0]
*   .connect reset reset[31:0]
*   .connect 0 gnd[31:0]
*
*   Xinc a[31:0] f[31:0] 0 d[31:0] cout[31:30] add32
*   Xreset reset[31:0] d[31:0] gnd[31:0] temp[31:0] mux2
*   Xid temp[31:0] regclk[31:0] f[31:0] dreg
* .ends
*
* * once every 5ns
* Vclkf1 clkf1 0 pulse(0,5,2.4ns,.1ns,.1ns,2.4ns)
*
* Xcounter32_debug reset incr[31:0] reg_debug[31:0] d[31:0] temp[31:0] clkf1 counter32_debug
*
* .plot sd(d[31:0])
* .plot sd(temp[31:0])
* .plot clkf1
* .plot sd(reg_debug[31:0])
*******************************************************************************
* a)
* At times, there is a significant delay between the changes in input and
* output because the clock changes to logic 1 before the values for incr or
* reset change.
*
* Using the plot of clk1 as an example, we can see that when the value of reset
* changes to logic 1 at 215ns, the output of the register still decrements
* instead of resetting. When we look closely, the clock changes to logic 1
* before reset changes to logic 1, meaning that the register subcircuit still
* uses the value of 0 for reset.
*
* If we use a slower clock like that of clk3 as another example, we can see
* that when the value of incr changes from 1 to 3 at 100ns, the output of
* register is still an increment of 1. Looking closely, the clock also changes
* to logic 1 before the value of incr changes, so the register subcircuit uses
* the value of 1 for incr.
*
* b)
* When plotting the waveform of the same circuit with a faster clock, we will
* find an error at around 150ns when incrementing using -1. Since -1 in bits is
* entirely composed of 1s, this causes a long propagation delay in the 32-bit
* adder. Because of the longer propagation delay, the value of the sum is still
* noisy/uncertain at the next positive edge of the clock cycle.
*
* What is stopping us is the short contamination delay and long propagation
* delay of the 32-bit adder, leading to long periods of noise/uncertainty when
* calculating the sum. Since the clock cycle is shorter, there is a higher
* chance that the delay will reach the next positive edge. If the worst
* transition delay of the 32-bit adder is greater than the amount of time the
* clock spends on logic 0, there will be cases where the contamination of the
* sum reaches the positive edge of the clock, therefore contaminating the value
* in the register.
*******************************************************************************